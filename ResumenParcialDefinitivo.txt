RESUMEN IRAT PARCIAL:


Tiempo de ejecuci√≥n de instrucci√≥nes en dos bucles anidados = tiempo de ejecuci√≥n de instrucci√≥nes del bucle interno.


Tiempo de ejecuci√≥n de bucles consecutivos = tiempo de ejecuci√≥n de bucle dominante.


TDA LISTA:

Operaciones:

Insertar - O(n)

  tlista.insertar(unElemento : tipoElemento)
  COM
   Si vacia entonces 
     primero = unElemento
   sino
     actual = primero
     mientras actual.siguiente <> nulo
         actual = actual.siguiente
     fin mientras
     actual.siguiente = unElemento
   fin si
  FIN

Eliminar - O(n)

tlista.eliminar(unaClave : tipoclave) : boolean
COM
 Si lista.esVacia entonces
    devolver false
 sino
  si primero.siguiente = nulo
     si primero.etiqueta = unaClave
        primero = nulo //Eliminamos al nodo
        devolver true
     fin si
  fin si
  actual = primero

Si actual.etiqueta = clave entonces
   aux1 = actual
   aux2 = aux1.siguiente
   primero = aux2
   devolver true
fin si

mientras actual.siguiente <> nulo hacer
  si actual.siguiente.etiqueta = unaClave
     aux3 = actual.siguiente
     devolver true
  fin si
  actual = actual.siguiente
fin mientras
devolver true

FIN

Buscar - O(n)
  tlista.buscar(unaEtiqueta : tipoEtiqueta) : Telemento
  COM
    Si vacia entonces
      devolver nulo
    sino
      actual = primero
      mientras actual <> nulo
        Si actual.etiqueta = unaetiqueta
          devolver actual
        fin si
        actual = actual.siguiente
      fin mientras
      devolver nulo
   fin si
 FIN

TDA PILA - TIPO DE LISTA, TODAS LAS OPERACI√ìNES DE LISTA SON V√ÅLIDAS PARA LAS PILAS

Operaciones:

push: Agrega un elemento en la parte superior de la pila O(1)

pop: elimina y devuelve el elemento que est√° en la parte superior de la pila O(1)

peek: devuelve el elemento que est√°n en la parte superior de la pila, sin eliminarlo O(1)

isEmpty: verifica si la pila esta vac√≠a O(1)

-Anula(Vac√≠a la pila)
‚Äì Tope = "peek"
‚Äì Saca ‚Äì "pop"
‚Äì Mete ‚Äì "push"
‚Äì Vac√≠a "isEmpty"



TDA COLA: TIPO DE LISTA, TODAS LAS OPERACI√ìNES DE LISTA SON V√ÅLIDAS PARA LAS COLAS
-Anula (vac√≠a la cola)
‚Äì Frente(devuelve el elemento q esta al frente de cola, no elimina) O(1)
‚Äì PoneEnCola(agrega elemento a cola) O(1)
‚Äì QuitaDeCola(elimina de cola) O(1)
‚Äì Vac√≠a(verifica si cola est√° vac√≠a) O(1)



RECURSIVIDAD:

Si el m√©todo contiene una referencia a s√≠ mismo est√° ESTRICTAMENTE RECURSIVO.

Si un m√©todo1 contiene una referencia a otro m√©todo2 que a su vez referencia a m√©todo1, entonces est√° indirectamente recursivo.

Recursi√≥n Lineal:

-Tiene un caso base que no USA RECURSIVIDAD.

-Realiza UNA SOLA llamada RECURSIVA.

Recursi√≥n Binaria:

-Hay 2 LLAMADAS RECURSIVAS, para cada caso NO-BASE

Recursi√≥n de Cola:

-Llamada RECURSIVA ocurre en la ULTIMA SENTENCIA.


√ÅRBOLES:

√Årbol Binario:

Cada nodo interno tiene como M√ÅXIMO 2 HIJOS.

√Årbol binario de b√∫squeda:

Para cada nodo ti, todas las claves del sub√°rbol izquierdo de ti son menores que la clave de ti, y todas las claves del √°rbol derecho son mayores que la clave de ti.

-Si √°rbol tiene N nodos y est√° balanceado, altura = log(n)

Profundidad:

-Longitud del camino que va desde la ra√≠z hasta ese nodo.


Altura:

-Longitud del camino que va desde ese nodo hasta la hoja m√°s profunda.


Altura de un √ÅRBOL:

-Altura de su ra√≠z


Hoja:

-Nodo que NO tiene hijos

Hermanos:

-Nodos que tienen el mismo padre.


Ancestro:

-Si existe un camino desde el nodo u hasta el nodo v, entonces u es un ancestro de v

Descendiente:

-Si existe un camino desde el nodo u hasta el nodo v, entonces v es un descendiente de u

Ancestro propio:

-Mismo concepto que ancestro, pero sin contar al propio Nodo.

Descendiente Propio:

-Mismo concepto que descendiente, pero si contar al propio Nodo.


Tama√±o de un Nodo:

-N√∫mero de descendientes + el propio nodo.

Tama√±o de un √ÅRBOL:

-Tama√±o de la ra√≠z


Recorridos:

INORDEN = Hijo izquierdo, Ra√≠z, hijo derecho

PREORDEN = Ra√≠z, Hijo izquierdo, Hijo derecho.

POSTORDEN = Hijo izquierdo, Hijo derecho, Ra√≠z


Operaciones √Årbol binario de b√∫squeda

Insertar: O(log N) si est√° balanceado, O(n) si no est√° balanceado

Insertar(UnElementoArbolBinario)
    COM
    SI Etiqueta = unElementoArbolBinario.Etiqueta ENTONCES
        SALIR // ya est√° en el √°rbol
    FINSI
    SI unElementoArbolBinario.Etiqueta < Etiqueta ENTONCES
        SI HijoIzquierdo = nulo ENTONCES
            HijoIzquierdo ü°® unElementoArbolBinario
        SINO 
            HijoIzquierdo.Insertar(unElementoArbolBinario)
        FINSI
    SINO
        SI HijoDerecho = nulo ENTONCES
            HijoDerecho ü°® unElementoArbolBinario
        SINO 
            HijoDerecho.Insertar(unElementoArbolBinario)
        FINSI
    FINSI
FIN


Buscar: O(log N) si est√° balanceado, O(n) si no est√° balanceado

Buscar(UnaEtiqueta) : TElementoABinario
    RESULTADO = nulo
    SI UnaEtiqueta = Etiqueta ENTONCES
        RESULTADO = THIS
    SINO
        SI UnaEtiqueta < Etiqueta ENTONCES
            SI HijoIzquierdo <> nulo ENTONCES
                RESULTADO = HijoIzquierdo.Buscar(UnaEtiqueta)
            FINSI
        SINO
            SI HijoDerecho <> nulo ENTONCES
                RESULTADO = HijoDerecho.Buscar(UnaEtiqueta)
            FINSI
        FINSI
    FINSI
    RETORNAR RESULTADO
FIN



Eliminar: O(log N) si est√° balanceado, O(n) si no est√° balanceado

ElementoAB.Eliminar(UnaEtiqueta): de Tipo TElementoAB
    COM
    (1) Si UnaEtiqueta < etiqueta entonces // si est√°, est√° en el sub√°rbol izquierdo
        Si hijoIzq <> nulo entonces
            hijoIzq ü°® hijoIzq.eliminar(UnaEtiqueta) // actualiza el hijo, con el mismo u otro valor
        Finsi
        retornar (this) // al padre le devuelve el mismo hijo
    Finsi
    (2) Si UnaEtiqueta > etiqueta entonces // si est√°, est√° en el sub√°rbol derecho
        Si hijoDer <> nulo entonces  
            hijoDer ü°® hijoDer.eliminar(UnaEtiqueta) // actualiza el hijo, con el mismo u otro valor
        Finsi
        retornar (this) // al padre le devuelve el mismo hijo
    Finsi
    (3) retornar quitaElNodo() // est√°, hay que eliminarlo
    // al padre le devuelve el nuevo hijo
Fin
// Cuando encuentra el nodo a eliminar llama, por claridad, al m√©todo que hace el trabajo

























